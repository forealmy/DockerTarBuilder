name: Push Images to Fixed ACR Address

on:
  workflow_dispatch:
    inputs:
      docker_images:
        description: 'Docker 镜像列表（英文逗号分隔）'
        required: true
        default: 'nginx:latest,langgenius/dify-api:1.11.2'

jobs:
  push-to-acr:
    runs-on: ubuntu-22.04
    environment: acr-prod  # ← 确保这个 Environment 名称与你的设置一致
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Login to ACR
        env:
          ACR_TARGET_REGISTRY: crpi-dsuujqmghq4pfebi.cn-hangzhou.personal.cr.aliyuncs.com/my-dify-prod
          ALIYUN_ACCESS_KEY_ID: ${{ secrets.ALIYUN_ACCESS_KEY_ID }}
          ALIYUN_ACCESS_KEY_SECRET: ${{ secrets.ALIYUN_ACCESS_KEY_SECRET }}
        run: |
          ACR_REGISTRY_HOST=$(echo "$ACR_TARGET_REGISTRY" | cut -d'/' -f1)
      
          if [ -z "$ALIYUN_ACCESS_KEY_ID" ] || [ -z "$ALIYUN_ACCESS_KEY_SECRET" ]; then
            echo "❌ Missing AccessKey."
            exit 1
          fi
      
          echo "$ALIYUN_ACCESS_KEY_SECRET" | docker login \
            --username "$ALIYUN_ACCESS_KEY_ID" \
            --password-stdin \
            "$ACR_REGISTRY_HOST"
      
      - name: Push to ACR (Skip on Pull Failure)
        env:
          ACR_TARGET_REGISTRY: crpi-dsuujqmghq4pfebi.cn-hangzhou.personal.cr.aliyuncs.com/my-dify-prod
        run: |
          set -euo pipefail

          IFS=',' read -r -a IMAGES <<< "${{ github.event.inputs.docker_images }}"
          for IMAGE in "${IMAGES[@]}"; do
            IMAGE=$(echo "$IMAGE" | xargs)
            [ -z "$IMAGE" ] && continue
          
            echo ">>> Processing: $IMAGE"
          
            if [[ "$IMAGE" == *":"* ]]; then
              REPO_PART="${IMAGE%:*}"
              TAG_PART="${IMAGE##*:}"
            else
              REPO_PART="$IMAGE"
              TAG_PART="latest"
            fi
          
            # 输入: REPO_PART (e.g., "langgenius/dify-api")
            # 输出: CLEAN_REPO (e.g., "langgenius_0_dify-api")
            CLEAN_REPO=$(echo "$REPO_PART" | tr '[:upper:]' '[:lower:]')      # 转小写
            CLEAN_REPO=$(echo "$CLEAN_REPO" | sed 's/\//_0_/g')               # / → _0_
            CLEAN_REPO=$(echo "$CLEAN_REPO" | tr -cd 'a-z0-9._-')             # 只保留合法字符
            CLEAN_REPO=$(echo "$CLEAN_REPO" | sed 's/__*/_0_/g')              # 防御性：其他连续 _ 也转（可选）
            CLEAN_REPO=$(echo "$CLEAN_REPO" | sed 's/--*/-/g')                # 合并多个 -
            CLEAN_REPO=$(echo "$CLEAN_REPO" | sed 's/\.\.*/./g')              # 合并多个 .
            CLEAN_REPO=$(echo "$CLEAN_REPO" | sed 's/^[-._]*//' | sed 's/[-._]*$//')  # 去首尾非法字符
            [ -z "$CLEAN_REPO" ] && CLEAN_REPO="unknown"
          
            TARGET_IMAGE="$ACR_TARGET_REGISTRY/$CLEAN_REPO:$TAG_PART"
            echo "Tagging as: $TARGET_IMAGE"
          
            if ! docker pull "$IMAGE" --platform linux/amd64; then
              echo "⚠️  Skipping due to pull failure: $IMAGE"
              continue
            fi
          
            docker tag "$IMAGE" "$TARGET_IMAGE"
            docker push "$TARGET_IMAGE"
            docker rmi "$IMAGE" "$TARGET_IMAGE" 2>/dev/null || true
            docker image prune -f
          
            echo "<<< Success: $IMAGE → $TARGET_IMAGE"
          done

          docker logout "$ACR_REGISTRY_HOST"
